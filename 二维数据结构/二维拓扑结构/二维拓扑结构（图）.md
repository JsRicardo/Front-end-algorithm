# 二维拓扑结构（图）

* 二叉树 多叉树 都是基于拓扑结构生成的

```javascript
// 拓扑结构
function Node (value) {
    this.value = value
    this.neighbor = []
}

var node1 = new Node(1)
var node2 = new Node(2)
var node3 = new Node(3)
var node4 = new Node(4)

node1.neighbor.push(node2, node3)
node2.neighbor.push(node1, node4)
node3.neighbor.push(node1, node4)
node4.neighbor.push(nod2, node3)
```

## 树形结构（有向无环图）

* 树是图的一种
* 树有一个根节点
* 树没有环形结构（回路）
* 度： 树的最多叉的节点有多少叉，就有多少度
* 深度： 树最深有多少层，就是多少深度


### 二叉树
> 树的度最多为二的树

* 满二叉树
1. 所有的叶子节点都在最底层
2. 每个非叶子节点都有两个子节点

* 完全二叉树

> 国内定义
1. 叶子节点都在最后一层或者倒数第二层
2. 叶子节点都向左聚拢

> 国际定义
1. 叶子节点都在最后一层或者倒数第二层
2. 如果有叶子节点，就必须有两个叶子节点

#### 二叉树的遍历

* 前序遍历（前根次序遍历）先打印当前的，再打印左边的，再打印右边的
* 中序遍历（中根次序遍历）先打印左边的，先打印当前的，再打印右边的
* 后序遍历（后根次序遍历）先打印左边的，再打印右边的，先打印当前的

```javascript
// 构建二叉树
function TwoNode(val) {
    this.val = val
    this.left = null
    this.right = null
}

var a = new TwoNode('a')
var b = new TwoNode('b')
var c = new TwoNode('c')
var d = new TwoNode('d')
var e = new TwoNode('e')
var f = new TwoNode('f')
var g = new TwoNode('g')

a.left = b
a.right = c
b.left = e
b.right = f
c.left = g

// 前序遍历
function qianxu (node) {
    if (node === null) return
    console.log(node.val)
    qianxu(node.left)
    qianxu(node.right)
}

// 中序遍历
function zhongxu (node) {
    if (node === null) return
    qianxu(node.left)
    console.log(node.val)
    qianxu(node.right)
}

// 后序遍历
function houxu (node) {
    if (node === null) return
    qianxu(node.left)
    qianxu(node.right)
    console.log(node.val)
}
```

**中序遍历 根节点的左边是左子树； 前序遍历 第一个是根节点； 后序遍历 最后一个是根节点**
**用中序遍历确认左右子树，前后序遍历确认根节点**

```javascript
// 根据前序后序 还原二叉树
var qian = ['a', 'b', 'e', 'f', 'c', 'g', ]
var zhong = ['b', 'e', 'f', 'a', 'c', 'g', ]
var num = 0
function huanyuan(qian, zhong) {
    if (qian == null || zhong == null || qian.length == 0 || zhong.length == 0 || qian.length != zhong.length) return null;
    var root = new TwoNode(qian[0]) // 创建二叉树 根据前序找到根节点
    var zhongIdx = zhong.indexOf(root.val) // 在中序中找到根节点位置
    var qLeft = qian.slice(1, zhongIdx + 1) // 前序左子树
    var qRight = qian.slice(zhongIdx + 1, qian.length) // 前序右子树
    var zLeft = zhong.slice(0, zhongIdx) // 中序左子树
    var zRight = zhong.slice(zhongIdx + 1, zhong.length) // 中序右子树
    root.right = huanyuan(qLeft, zLeft)
    root.left = huanyuan(qRight, zRight)
    return root
}
var root = huanyuan(qian, zhong)
```